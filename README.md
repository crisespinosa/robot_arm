# Управление манипулятором UR5e в Unity с использованием принципа максимума Понтрягина (PMP)

Данный проект реализует модель манипулятора **UR5e** в среде **Unity** с планированием траекторий во внешнем **C++ backend** на основе **принципа максимума Понтрягина (PMP)**.
Управление полностью отделено от визуализации и осуществляется напрямую в **суставном пространстве (6 степеней свободы)**.

---

## 1. Установка и запуск (пошагово)

### 1.1 Backend (C++ / Drogon)

Исходный код backend находится в папке:

```
robot_arm/
```

Сервер запускается на порту **8848** (см. `main.cc`):

```cpp
drogon::app().addListener("0.0.0.0", 8848);
```

#### Сборка

```bash
cd robot_arm
mkdir -p build
cd build
cmake ..
cmake --build .
```

#### Запуск

```bash
./robot_arm
```

После запуска backend доступен по адресу:

```
http://127.0.0.1:8848
```

---

### 1.2 Unity

Файлы Unity находятся в папке:

```
UR5e/Assets/
```

Основные скрипты:

- `arm.unity` — основная сцена
- `Ur5eTrajectoryClientQ.cs` — HTTP‑клиент (запрос и проигрывание траектории)
- `Ur5eSliderHandles.cs` — UI‑слайдеры («ручки») для управления суставами
- `ApplyJointAngles6.cs` — применение углов к модели UR5e
- `KeyboardJogSliders.cs` — управление с клавиатуры через слайдеры

URDF‑модель:

```
Assets/ur_description/urdf/ur5e.urdf
```

#### Запуск сцены

1. Открыть сцену `arm.unity`
2. Нажать **Play**
3. Изменять углы суставов слайдерами Q1–Q6
4. Нажать **Send** для отправки запроса в backend

---

## 2. Принцип максимума Понтрягина (PMP)

### 2.1 Динамическая модель

Каждый сустав моделируется независимо как **трёхкратный интегратор**.

Состояние:
- \( x_1 = q \) — угол сустава  
- \( x_2 = \dot{q} \) — угловая скорость  
- \( x_3 = \ddot{q} \) — угловое ускорение  

Управление:
- \( u = \dddot{q} \) — рывок (*jerk*)

Уравнения движения:
\[
\dot{x}_1 = x_2,\quad
\dot{x}_2 = x_3,\quad
\dot{x}_3 = u
\]

**В коде:**  
`trajectory_pmp_explicit_with_Jacc.hpp`, функция `plan_pmp_minimum_jerk()`

---

### 2.2 Функционал качества

Минимизируется интеграл квадрата рывка:

\[
J = \int_0^T \frac{1}{2} u(t)^2 \, dt
\]

Это обеспечивает плавное движение без резких изменений ускорения.

**В коде:**

```cpp
J_acc += 0.5 * u2 * dt;
p.J_acc = J_acc;
```

---

### 2.3 Гамильтониан

Гамильтониан имеет вид:

\[
H = \frac{1}{2}u^2 + \lambda_1 x_2 + \lambda_2 x_3 + \lambda_3 u
\]

Условие оптимальности:

\[
\frac{\partial H}{\partial u} = u + \lambda_3 = 0
\Rightarrow u^* = -\lambda_3
\]

**В коде:**

```cpp
p.lambda3[i] = -p.u[i];
```

---

### 2.4 Сопряжённые переменные

Уравнения для сопряжённых переменных:

\[
\dot{\lambda}_1 = 0,\quad
\dot{\lambda}_2 = -\lambda_1,\quad
\dot{\lambda}_3 = -\lambda_2
\]

Для наглядности PMP в коде используется согласованное восстановление:

\[
\lambda_3 = -u,\quad
\lambda_2 = \frac{du}{dt},\quad
\lambda_1 = -\frac{d^2u}{dt^2}
\]

**В коде:**

```cpp
p.lambda3[i] = -p.u[i];
p.lambda2[i] = du_dt;
p.lambda1[i] = -d2u_dt2;
```

---

### 2.5 Полином пятой степени

При стандартных граничных условиях:

\[
q(0)=q_0,\ \dot q(0)=0,\ \ddot q(0)=0
\]
\[
q(T)=q_1,\ \dot q(T)=0,\ \ddot q(T)=0
\]

оптимальная траектория имеет вид:

\[
q(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5
\]

**В коде:**

- `quintic_coeffs()` — вычисление коэффициентов \(a_0..a_5\)
- `plan_pmp_minimum_jerk()` — расчёт \(q, \dot q, \ddot q, u\)

---

## 3. Структура проекта

### Backend (`robot_arm/`)

- `main.cc` — запуск сервера Drogon
- `trajectory_pmp_explicit_with_Jacc.hpp` — реализация PMP
- `controllers/` — HTTP‑обработчики

### Unity (`UR5e/Assets/`)

- `Ur5eTrajectoryClientQ.cs` — взаимодействие с backend
- `Ur5eSliderHandles.cs` — слайдеры управления суставами
- `ApplyJointAngles6.cs` — применение углов
- `KeyboardJogSliders.cs` — управление с клавиатуры
- `arm.unity` — сцена

---

## 4. Примечания

- Инверсная кинематика (IK) была удалена, так как она была реализована только для 3 DOF.
- Управление осуществляется напрямую в суставном пространстве (6 DOF).
- Управление и визуализация полностью разделены.

---

## Автор

Проект выполнен в рамках учебно‑исследовательской работы по оптимальному управлению и планированию траекторий с использованием принципа максимума Понтрягина.
