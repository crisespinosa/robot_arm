# Управление манипулятором UR5e в Unity с использованием принципа максимума Понтрягина (PMP)

Данный проект реализует модель манипулятора **UR5e** в среде **Unity** с планированием траекторий во внешнем **C++ backend** на основе **принципа максимума Понтрягина (PMP)**.
Управление полностью отделено от визуализации и осуществляется напрямую в **суставном пространстве (6 степеней свободы)**.

---

## 1. Установка и запуск (пошагово)

### 1.1 Backend (C++ / Drogon)

Исходный код backend находится в папке:

```
robot_arm/
```

Сервер запускается на порту **8848** (см. `main.cc`):

```cpp
drogon::app().addListener("0.0.0.0", 8848);
```

#### Сборка

```bash
cd robot_arm
mkdir -p build
cd build
cmake ..
cmake --build .
```

#### Запуск

```bash
./robot_arm
```

После запуска backend доступен по адресу:

```
http://127.0.0.1:8848
```

---

### 1.2 Unity

Файлы Unity находятся в папке:

```
UR5e/Assets/
```

Основные скрипты:

- `arm.unity` — основная сцена
- `Ur5eTrajectoryClientQ.cs` — HTTP‑клиент (запрос и проигрывание траектории)
- `Ur5eSliderHandles.cs` — UI‑слайдеры («ручки») для управления суставами
- `ApplyJointAngles6.cs` — применение углов к модели UR5e
- `KeyboardJogSliders.cs` — управление с клавиатуры через слайдеры

URDF‑модель:

```
Assets/ur_description/urdf/ur5e.urdf
```

#### Запуск сцены

1. Открыть сцену `arm.unity`
2. Нажать **Play**
3. Изменять углы суставов слайдерами Q1–Q6
4. Нажать **Send** для отправки запроса в backend

---

## 2. Принцип максимума Понтрягина (PMP)

Ниже приведён используемый в проекте вариант PMP для планирования **минимального рывка (minimum-jerk)** в суставном пространстве.
Для каждого сустава планируется траектория $q(t)$ при минимизации квадрата рывка.

### 2.1 Обозначения (что значит каждый символ)

- $t$ — время, $t \in [0, T]$
- $T$ — длительность движения (сек)
- $dt$ — шаг дискретизации траектории (сек)
- $q(t)$ — угол сустава (рад)
- $\dot q(t)$ — угловая скорость (рад/с)
- $\ddot q(t)$ — угловое ускорение (рад/с²)
- $u(t)$ — управление, в данной модели $u(t)=\dddot q(t)$ (**рывок / jerk**, рад/с³)
- $\lambda_1(t), \lambda_2(t), \lambda_3(t)$ — сопряжённые переменные (costates)
- $J$ — функционал качества
- $J_{\text{acc}}(t_k)$ — накопленная стоимость до момента $t_k$
- $a_0,\dots,a_5$ — коэффициенты полинома 5-й степени
- `dof` — число степеней свободы (размерность $q$)

---

### 2.1 Динамическая модель (трёхкратный интегратор)

Каждый сустав моделируется как система третьего порядка.

Состояние:
- $( x_1 = q)$ — угол сустава  
- $( x_2 = \dot{q} )$ — угловая скорость  
- $( x_3 = \ddot{q})$ — угловое ускорение  

Управление:
- $( u = \dddot{q} )$ — рывок (*jerk*)

Уравнения движения:
$[
\dot{x}_1 = x_2,\quad
\dot{x}_2 = x_3,\quad
\dot{x}_3 = u
]$

**В коде:**
- `trajectory_pmp_explicit_with_Jacc.hpp`
- функция `plan_pmp_minimum_jerk()`
- структура `PMPPoint`:
  - `q` → $q(t)$  
  - `dq` → $\dot q(t)$  
  - `ddq` → $\ddot q(t)$  
  - `u` → $u(t)$  

---

### 2.3 Функционал качества

Минимизируется интеграл квадрата рывка:

$[
J = \int_0^T \frac{1}{2} u(t)^2 \, dt
]$

Это обеспечивает плавное движение без резких изменений ускорения.

Численно:
$$
J_{\text{acc}}(t_k) \approx \sum_{j=0}^{k} \frac{1}{2}\|u(t_j)\|^2\, dt
$$

**В коде:**
```cpp
u2 += p.u[i] * p.u[i];
J_acc += 0.5 * u2 * dt;
p.J_acc = J_acc;

### 2.3 Гамильтониан

Гамильтониан имеет вид:

$[
H = \frac{1}{2}u^2 + \lambda_1 x_2 + \lambda_2 x_3 + \lambda_3 u
]$

Условие оптимальности:

$[
\frac{\partial H}{\partial u} = u + \lambda_3 = 0
\Rightarrow u^* = -\lambda_3
]$

**В коде:**

```cpp
p.lambda3[i] = -p.u[i];
```

---

### 2.5 Сопряжённые переменные

Из принципа максимума Понтрягина:

$$
\dot{\lambda} = -\frac{\partial H}{\partial x}
$$

Получаем систему дифференциальных уравнений для сопряжённых переменных:

$$
\dot{\lambda}_1 = 0,
\qquad
\dot{\lambda}_2 = -\lambda_1,
\qquad
\dot{\lambda}_3 = -\lambda_2
$$

ДВ коде используется согласованное восстановление сопряжённых переменных через управление $u(t)$:

$$
\lambda_3 = -u,
\qquad
\lambda_2 = \frac{du}{dt},
\qquad
\lambda_1 = -\frac{d^2u}{dt^2}
$$

В реализации это соответствует следующему коду:

```cpp
p.lambda3[i] = -p.u[i];
p.lambda2[i] = du_dt;
p.lambda1[i] = -d2u_dt2;
```
---

### 2.5 Полином пятой степени 

При стандартных граничных условиях:

$[
q(0)=q_0,\ \dot q(0)=0,\ \ddot q(0)=0
]$
$[
q(T)=q_1,\ \dot q(T)=0,\ \ddot q(T)=0
]$

Оптимальная траектория минимального рывка задаётся полиномом пятой степени:

$[
q(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5
]$

#### Производные по времени

Скорость:

$$
\dot q(t) = a_1 + 2 a_2 t + 3 a_3 t^2 + 4 a_4 t^3 + 5 a_5 t^4
$$

Ускорение:

$$
\ddot q(t) = 2 a_2 + 6 a_3 t + 12 a_4 t^2 + 20 a_5 t^3
$$

Рывок (управление):

$$
u(t) = \dddot q(t) = 6 a_3 + 24 a_4 t + 60 a_5 t^2
$$

#### Соответствие коду

- `quintic_coeffs()` — вычисление коэффициентов $a_0 \dots a_5$
- `solve6()` — решение системы линейных уравнений для нахождения коэффициентов
- `plan_pmp_minimum_jerk()` — вычисление $q(t)$, $\dot q(t)$, $\ddot q(t)$ и $u(t)$

---


## 3. Структура проекта

Проект разделён на две логические части:  
**backend** (расчёт траекторий и оптимального управления) и **Unity** (визуализация и интерактивное управление роботом).

---

### Backend (`robot_arm/`)

Backend реализован на C++ с использованием фреймворка **Drogon** и отвечает за вычисление оптимальных траекторий движения суставов манипулятора.

- `main.cc`  
  Точка входа приложения. Запуск HTTP-сервера Drogon и прослушивание порта `8848`.

- `trajectory.hpp`  
  Ключевой файл проекта. Содержит:
  - реализацию принципа максимума Понтрягина (PMP);
  - полином пятой степени (minimum jerk);
  - вычисление $q(t)$, $\dot q(t)$, $\ddot q(t)$ и $u(t)$ (jerk);
  - вычисление сопряжённых переменных $\lambda_1, \lambda_2, \lambda_3$;
  - накопление функционала стоимости $J$.

- `dynamics.hpp`  
  Упрощённая динамическая модель манипулятора:
  - хранение состояния суставов $(q, \dot q)$;
  - численная интеграция движения по времени;
  - ограничения по углам и скоростям суставов.

- `ArmController.h`  
  Описание HTTP-контроллера:
  - объявление REST-методов;
  - интерфейс обработки запросов от Unity;
  - связь между динамической моделью и планировщиком траекторий.

- `ArmController.cc`  
  Реализация логики backend:
  - приём целевых углов суставов (6 DOF);
  - вызов `plan_minjerk()` и `plan_pmp_minimum_jerk()`;
  - формирование JSON-ответов с траекторией;
  - разделение вычислений (backend) и визуализации (Unity).

- `controllers/`  
  HTTP-контроллеры Drogon:
  - маршрут `/arm/plan_pmp_q`;
  - обработка входных JSON-запросов;
  - возврат рассчитанных траекторий клиенту.

---

### Unity (`UR5e/Assets/`)

Unity-часть отвечает за визуализацию UR5e и пользовательское управление.

- `Ur5eTrajectoryClientQ.cs`  
  Клиент для связи с backend:
  - отправка HTTP-запросов;
  - получение PMP-траектории;
  - пошаговое воспроизведение движения во времени.

- `ApplyJointAngles6.cs`  
  Применение рассчитанных углов $q(t)$ к 6 суставам робота в Unity.

- `Ur5eSliderHandles.cs`  
  UI-слайдеры («ручки») для ручного задания углов суставов:
  - управление в градусах;
  - отправка целевого положения в backend;
  - сброс в начальную позу.

- `KeyboardJogSliders.cs`  
  Управление суставами с клавиатуры:
  - плавное изменение углов;
  - интеграция с теми же слайдерами.


- `arm.unity`  
  Основная сцена Unity с моделью UR5e, UI и подключёнными скриптами.

---

## 4. Примечания

- Инверсная кинематика (IK) была удалена, так как она была реализована только для 3 DOF.
- Управление осуществляется напрямую в суставном пространстве (6 DOF).
- Управление и визуализация полностью разделены.


